VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
  Persistable = 0  'NotPersistable
  DataBindingBehavior = 0  'vbNone
  DataSourceBehavior  = 0  'vbNone
  MTSTransactionMode  = 0  'NotAnMTSObject
END
Attribute VB_Name = "clsHTTP"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = True
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
' ######################################
' ##
' ##  LightQ HTTP engine
' ##

Option Explicit

Private Declare Function InternetOpen Lib "Wininet" Alias "InternetOpenA" (ByVal sAgent As String, ByVal lAccessType As Long, ByVal sProxyName As String, ByVal sProxyBypass As String, ByVal lFlags As Long) As Long
Private Declare Function InternetConnect Lib "Wininet" Alias "InternetConnectA" (ByVal hInternetSession As Long, ByVal sServerName As String, ByVal nServerPort As Integer, ByVal sUsername As String, ByVal sPassword As String, ByVal lService As Long, ByVal lFlags As Long, ByVal lContext As Long) As Long
Private Declare Function InternetOpenUrl Lib "Wininet" Alias "InternetOpenUrlA" (ByVal hInternetSession As Long, ByVal sURL As String, ByVal sHeaders As String, ByVal lHeadersLength As Long, ByVal lFlags As Long, ByVal lContext As Long) As Long
Private Declare Function InternetReadFile Lib "Wininet" (ByVal hFile As Long, ByVal sBuffer As String, ByVal lNumBytesToRead As Long, lNumberOfBytesRead As Long) As Long
Private Declare Function InternetCloseHandle Lib "Wininet" (ByVal hInet As Long) As Long
Private Declare Function InternetGetLastResponseInfo Lib "Wininet" Alias "InternetGetLastResponseInfoA" (ByRef lpdwError As Long, ByVal lpszBuffer As String, ByRef lpdwBufferLength As Long) As Long
Private Declare Function InternetCrackUrl Lib "Wininet" Alias "InternetCrackUrlA" (ByVal lpszUrl As String, ByVal dwUrlLength As Long, ByVal dwFlags As eCanonizeURL, lpUrlComponents As URL_COMPONENTSA) As Long
Private Declare Function HttpAddRequestHeaders Lib "Wininet" Alias "HttpAddRequestHeadersA" (ByVal hHttpRequest As Long, ByVal sHeaders As String, ByVal lHeadersLength As Long, ByVal lModifiers As Long) As Long
Private Declare Function HttpOpenRequest Lib "Wininet" Alias "HttpOpenRequestA" (ByVal hHttpSession As Long, ByVal sVerb As String, ByVal sObjectName As String, ByVal sVersion As String, ByVal sReferer As String, ByVal sAcceptTypes As String, ByVal lFlags As Long, ByVal lContext As Long) As Long
Private Declare Function HttpSendRequest Lib "Wininet" Alias "HttpSendRequestA" (ByVal hHttpRequest As Long, ByVal sHeaders As String, ByVal lHeadersLength As Long, ByVal sOptional As Any, ByVal lOptionalLength As Long) As Long
Private Declare Function HttpQueryInfo Lib "Wininet" Alias "HttpQueryInfoA" (ByVal hRequest As Long, ByVal dwInfoLevel As Long, ByRef lpBuffer As Any, ByRef lpdwBufferLength As Long, ByRef lpdwIndex As Long) As Long

Private Const HTTP_ADDREQ_FLAG_ADD = &H20000000            'Add HTTP headerfield
Private Const HTTP_ADDREQ_FLAG_REPLACE = &H80000000        'Replace HTTP headerfield if it already exists

Private Const HTTP_QUERY_RAW_HEADERS_CRLF = 22             'Special: all headers
Private Const HTTP_QUERY_RAW_HEADERS = 21
Private Const HTTP_QUERY_VERB = 902
Private Const HTTP_QUERY_STATUS_CODE = 19
Private Const HTTP_QUERY_STATUS_TEXT = 20

Private Const INTERNET_FLAG_EXISTING_CONNECT = &H20000000  'Attempts to use an existing InternetConnect object if one exists with the same
                                                           'attributes required to make the request. This is useful only with FTP operations,
                                                           'since FTP is the only protocol that typically performs multiple operations during
                                                           'the same session. The WinINet API caches a single connection handle for each HINTERNET handle
                                                           'generated by InternetOpen.

Private Const INTERNET_FLAG_NO_AUTH = &H40000              'Does not attempt authentication automatically.

Private Const INTERNET_FLAG_RELOAD = &H80000000            'Forces a download of the requested file, object, or directory listing from the origin server,
                                                           'not from the cache.

Private Const INTERNET_FLAG_SECURE = &H800000              'Uses secure transaction semantics. This translates to using Secure Sockets Layer/Private
                                                           'Communications Technology (SSL/PCT) and is only meaningful in HTTP requests.

Private Const INTERNET_FLAG_NO_CACHE_WRITE = &H4000000     'Disables the caching of data on local disk
       
Private Const INTERNET_OPEN_TYPE_DIRECT = &H1              'Connects directly to the remote server without trying to use any caches or proxyservers

Private Const INTERNET_DEFAULT_HTTP_PORT = 80              'Default HTTP port (80)
Private Const INTERNET_DEFAULT_HTTPS_PORT = 443            'Default Secure HTTP port (443)

Private Const INTERNET_SERVICE_HTTP = 3                    'Service to use (HTTP)

Private Const ERROR_INTERNET_EXTENDED_ERROR = &H2EE3       'Extended error flag
       
Private Const BUFFER_LEN = 4096                            'Receive window (4k chunks)

Private Enum eMaxWinInetValues
  INTERNET_MAX_HOST_NAME_LENGTH = 256
  INTERNET_MAX_USER_NAME_LENGTH = 128
  INTERNET_MAX_PASSWORD_LENGTH = 128
  INTERNET_MAX_PORT_NUMBER_LENGTH = 5          ' INTERNET_PORT is unsigned short
  INTERNET_MAX_PORT_NUMBER_VALUE = 65535       ' maximum unsigned short value
  INTERNET_MAX_PATH_LENGTH = 2048
  INTERNET_MAX_SCHEME_LENGTH = 32              ' longest protocol name length
  INTERNET_MAX_URL_LENGTH = INTERNET_MAX_SCHEME_LENGTH + 3 + INTERNET_MAX_PATH_LENGTH
End Enum

Private Enum INTERNET_SCHEME
  INTERNET_SCHEME_PARTIAL = -2
  INTERNET_SCHEME_UNKNOWN = -1
  INTERNET_SCHEME_DEFAULT = 0
  INTERNET_SCHEME_FTP
  INTERNET_SCHEME_GOPHER
  INTERNET_SCHEME_HTTP
  INTERNET_SCHEME_HTTPS
  INTERNET_SCHEME_FILE
  INTERNET_SCHEME_NEWS
  INTERNET_SCHEME_MAILTO
  INTERNET_SCHEME_SOCKS
  INTERNET_SCHEME_FIRST = INTERNET_SCHEME_FTP
  INTERNET_SCHEME_LAST = INTERNET_SCHEME_SOCKS
End Enum

Private Type URL_COMPONENTSA
  dwStructSize      As Long
  lpszScheme        As String
  dwSchemeLength    As Long
  nScheme           As INTERNET_SCHEME
  lpszHostName      As String
  dwHostNameLength  As Long
  nPort             As Integer
  lpszUsername      As String
  dwUserNameLength  As Long
  lpszPassword      As String
  dwPasswordLength  As Long
  lpszUrlPath       As String
  dwUrlPathLength   As Long
  lpszExtraInfo     As String
  dwExtraInfoLength As Long
End Type

Private Enum eCanonizeURL
  ICU_ESCAPE = &H80000000             '(un)escape URL characters
  ICU_DECODE = &H10000000             'Convert %XX escape sequences To characters
End Enum

Private HTTP_Header    As String      'Local HTTP header buffer
Private HTTP_Extra     As String      'Local HTTP post data buffer
Private HTTP_RetHeader As String      'Local HTTP return header buffer
Private cStatus        As PictureBox  'Local Status window
Private colText        As Long
Private colPrg         As Long
Private hSession       As Long
Private hConnect       As Long
Private hRequest       As Long
    
'#######################################################################################
'List of commonly used MIME types for use with "Content-Type" and "Accept" header fields
'#######################################################################################
'
'application/mac-binhex40 hqx
'application/msword doc
'application/octet-stream bin dms lha lzh exe class
'application/pdf pdf
'application/postscript ai eps ps
'application/smil smi smil
'application/vnd.mif mif
'application/vnd.ms-asf asf
'application/vnd.ms-excel xls
'application/vnd.ms-powerpoint ppt
'application/x-cdlink vcd
'application/x-compress Z
'application/x-cpio cpio
'application/x-csh csh
'application/x-director dcr dir dxr
'application/x-dvi dvi
'application/x-gtar gtar
'application/x-gzip gz
'application/x-javascript js
'application/x-latex latex
'application/x-sh sh
'application/x-shar shar
'application/x-shockwave-flash swf
'application/x-stuffit sit
'application/x-tar tar
'application/x-tcl tcl
'application/x-tex tex
'application/x-texinfo texinfo texi
'application/x-troff t tr roff
'application/x-troff-man man
'application/x-troff-me me
'application/x-troff-ms ms
'application/zip zip
'audio/basic au snd
'audio/midi mid midi kar
'audio/mpeg mpga mp2 mp3
'audio/x-aiff aif aiff aifc
'audio/x-pn-realaudio ram rm
'audio/x-realaudio ra
'audio/x-wav wav
'image/bmp bmp
'image/gif gif
'image/ief ief
'image/jpeg jpeg jpg jpe
'image/png png
'image/tiff tiff tif
'image/x-cmu-raster ras
'image/x-portable-anymap pnm
'image/x-portable-bitmap pbm
'image/x-portable-graymap pgm
'image/x-portable-pixmap ppm
'image/x-rgb rgb
'image/x-xbitmap xbm
'image/x-xpixmap xpm
'image/x-xwindowdump xwd
'model/iges igs iges
'model/mesh msh mesh silo
'model/vrml wrl vrml
'text/css css
'text/html html htm
'text/plain asc txt
'text/richtext rtx
'text/rtf rtf
'text/sgml sgml sgm
'text/tab-separated-values tsv
'text/xml xml
'video/mpeg mpeg mpg mpe
'video/quicktime qt mov
'video/x-msvideo avi

Public Function FetchURL(ByVal sURL As String, Optional ByVal bHeadersOnly As Boolean = False, Optional ByVal UseProgress As Boolean = True) As String
    
    Dim sBuffer   As String * BUFFER_LEN
    Dim qBuffer   As String
    Dim sData     As String
    Dim lReturn   As Long
    Dim iReturn   As Long
    Dim cURL      As URL_COMPONENTSA
    Dim bTotal    As Long
    
    ' ### split URL into parts
    cURL = CrackURL(sURL)
    
    ' ### get the handle of the current internet connection
    hSession = InternetOpen("Class.HTTP", INTERNET_OPEN_TYPE_DIRECT, vbNullString, vbNullString, 0&)
    
    If hSession Then
       
       ' ### If we want to send a POST to the server we first have to make a connection with it
       ' ### because we are actually going to send data to the server
       
       ' ### establish a connection
       If Len(HTTP_Extra) Then
       
          hConnect = InternetConnect(hSession, _
                                     cURL.lpszHostName, _
                                     INTERNET_DEFAULT_HTTP_PORT, _
                                     cURL.lpszUsername, _
                                     cURL.lpszPassword, _
                                     INTERNET_SERVICE_HTTP, 0&, 0&)
       
          If hConnect Then
         
             ' ### prepare for a request
             hRequest = HttpOpenRequest(hConnect, _
                                        IIf(Len(HTTP_Extra), "POST", "GET"), _
                                        cURL.lpszUrlPath & cURL.lpszExtraInfo, _
                                        vbNullString, _
                                        vbNullString, _
                                        vbNullString, _
                                        INTERNET_FLAG_RELOAD Or INTERNET_FLAG_NO_CACHE_WRITE, 0&)
             
             If hRequest Then
             
                ' #####################################
                ' Add the custom headers to the request
                ' #####################################
                '
                If Len(HTTP_Header) Then
                   If HttpAddRequestHeaders(hRequest, HTTP_Header, Len(HTTP_Header), HTTP_ADDREQ_FLAG_REPLACE Or HTTP_ADDREQ_FLAG_ADD) = 0 Then
                      MsgBox "Class:clsHTTP.FetchURL -> Add headers failed", vbExclamation Or vbOKOnly
                   End If
                End If
          
                ' ######################################
                ' Add the extra POST data to the request
                ' ######################################
                '
                If Len(HTTP_Extra) Then
                   If HttpSendRequest(hRequest, vbNullString, 0&, HTTP_Extra, Len(HTTP_Extra)) = 0 Then
                      MsgBox "Class:clsHTTP.FetchURL -> Add extra postdata failed.", vbExclamation Or vbOKOnly
                   End If
                End If
                       
                ' ### read the remote file
                iReturn = InternetReadFile(hRequest, sBuffer, BUFFER_LEN, lReturn)
          
                If iReturn Then
                   ' ### read the returned HTTP header
                   lReturn = BUFFER_LEN
                   Do
                     qBuffer = Space(lReturn)
                     lReturn = Len(qBuffer)
                     iReturn = HttpQueryInfo(hRequest, HTTP_QUERY_RAW_HEADERS_CRLF, ByVal qBuffer, lReturn, 0&)
                   Loop Until iReturn <> 0 Or lReturn = 0
                   
                   HTTP_RetHeader = Left(qBuffer, lReturn)
                   
                   If iReturn Then
                     bTotal = Val(ExtractHeader("Content-Length", HTTP_RetHeader))
                   End If
                   
                   If Not bHeadersOnly Then
                      ' ### reset progressbar (if linked to this Class)
                      If UseProgress Then ShowStatus 0, 1
    
                      ' ### read rest of file
                      sData = sBuffer
                      Do While lReturn <> 0 And iReturn <> 0
                         iReturn = InternetReadFile(hRequest, sBuffer, BUFFER_LEN, lReturn)
                         sData = sData & Left(sBuffer, lReturn)
                         If UseProgress Then ShowStatus Len(sData), bTotal
                         DoEvents
                      Loop
                   End If
                   
                End If
                       
                Call InternetCloseHandle(hRequest)
          
             End If
       
             Call InternetCloseHandle(hConnect)
       
          End If
       
       Else
       
          ' ### We only want to download a file and we don't want to send any data to the server
          ' ### so simply open the URL and read the contents
       
          hRequest = InternetOpenUrl(hSession, sURL, HTTP_Header, Len(HTTP_Header), INTERNET_FLAG_RELOAD Or INTERNET_FLAG_NO_CACHE_WRITE, 0&)
          
          If hRequest Then
          
             ' ### read the remote file
             iReturn = InternetReadFile(hRequest, sBuffer, BUFFER_LEN, lReturn)
             
             If iReturn Then
                ' ### read the returned HTTP header
                lReturn = BUFFER_LEN
                Do
                   qBuffer = Space(lReturn)
                   lReturn = Len(qBuffer)
                   iReturn = HttpQueryInfo(hRequest, HTTP_QUERY_RAW_HEADERS_CRLF, ByVal qBuffer, lReturn, 0&)
                Loop Until iReturn <> 0 Or lReturn = 0
                
                HTTP_RetHeader = Left(qBuffer, lReturn)
                
                If iReturn Then
                   bTotal = Val(ExtractHeader("Content-Length", HTTP_RetHeader))
                End If
                
                If Not bHeadersOnly Then
                   ' ### reset progressbar (if linked to this Class)
                   If UseProgress Then ShowStatus 0, 1
    
                   ' ### read rest of file
                   sData = sBuffer
                   Do While lReturn <> 0 And iReturn <> 0
                      iReturn = InternetReadFile(hRequest, sBuffer, BUFFER_LEN, lReturn)
                      sData = sData & Left(sBuffer, lReturn)
                      If UseProgress Then ShowStatus Len(sData), bTotal
                      DoEvents
                   Loop
                End If
                
             End If
                
             Call InternetCloseHandle(hRequest)
          
          End If
       
       End If
       
       Call InternetCloseHandle(hSession)
       
    End If
    
    ' ### clear header and extra data
    HTTP_Header = vbNullString
    HTTP_Extra = vbNullString
                
    If Len(sData) <> bTotal And Not cStatus Is Nothing Then
       cStatus.Cls
    End If
                
    ' ### return received data
    FetchURL = sData
        
End Function

Public Sub LinkProgressBar(cProgress As PictureBox, Optional ByVal TextColor As Long = vbInfoText, Optional ByVal cFore As Long = vbBlue, Optional ByVal cBack As Long = vbButtonFace)
    ' ### apply the picturebox to out local picturebox and initialize it
    Set cStatus = cProgress
    With cStatus
      .AutoRedraw = True
      .Tag = vbNullString
      .ScaleMode = vbPixels
      .ForeColor = cFore
      .BackColor = cBack
      .Font = "Arial"
      .FontBold = True
      .FontSize = 10
      .Cls
      colPrg = cFore
      colText = TextColor
    End With
End Sub

Public Function GetHeader() As String
    ' ### returns the returned header of the request
    GetHeader = HTTP_RetHeader
End Function

Public Sub AddPostData(ByVal sPostData As String, Optional ByVal sContentType As String = "application/x-www-form-urlencoded")
    ' ### always use a content type when POSTing data
    If Len(HTTP_Extra) = 0 Then
       AddHeader "Content-Type: " & sContentType
    End If
    HTTP_Extra = HTTP_Extra & Trim(sPostData)
End Sub

Public Sub AddHeader(ByVal sHeaderField As String)
    ' ### adds a HTTP header field
    Const CHECK_FOR_FIELD As String = "authorization"
    If Left(Trim(LCase(sHeaderField)), Len(CHECK_FOR_FIELD)) = CHECK_FOR_FIELD Then
       MsgBox "Class:clsHTTP.AddHeader -> Authorization, use AddAuthorization instead.", vbExclamation Or vbOKOnly
       Exit Sub
    End If
    HTTP_Header = HTTP_Header & Trim(sHeaderField) & vbCrLf
End Sub

Public Sub AddAuthorization(ByVal sUsername As String, ByVal sPassword As String)
    ' ### adds the authorization header field with base64 encoded user/password combo
    HTTP_Header = HTTP_Header & "Authorization: Basic " & Base64Encode(Trim(sUsername) & ":" & Trim(sPassword)) & vbCrLf
End Sub

Public Function ClassLastError() As String
    ' ### returns the last DLL error occured
    ClassLastError = Err.LastDllError
End Function

Public Function ClassLastResponseInfo(Optional ErrCode As Long) As String
    ' ### returns last response info
    Dim eBuffer As String
    Dim eErr    As Long
    Dim lBuffer As Long
    eBuffer = Space(256)
    ErrCode = 0
    If InternetGetLastResponseInfo(eErr, eBuffer, lBuffer) Then
       ClassLastResponseInfo = Left(eBuffer, lBuffer)
       ErrCode = eErr
    End If
End Function

Public Function URLEncode(ByVal sURL As String) As String
  ' ### encodes a URL according to RFC 1738
  Dim Encoded As String
  Dim Char    As String
  Dim i       As Long
  Const cValid As String = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_. "
  For i = 1 To Len(sURL)
     Char = Mid(sURL, i, 1)
     If InStr(1, cValid, Char) = 0 Then
        Encoded = Encoded & "%" & Hex(Asc(Char))
     Else
        Encoded = Encoded & Char
     End If
  Next
  URLEncode = Encoded    ' ADDON: Non RFC 1738 compliant:  Replace(Encoded, Chr(&H20), "+")
End Function

Public Function ExtractHeader(ByVal sField As String, ByVal sHeader As String, Optional ByVal iIndex As Long = 1) As String
  ' ### returns the value of the specified headerfield, iIndex is used for multiple fields with same name (like Set-Cookie)
  Dim S As Long
  Dim e As Long
  Dim r As Long
  sField = sField & ": "
  S = 0
  r = 0
  Do
    S = InStr(S + 1, sHeader, sField, vbTextCompare)
    r = r + 1
  Loop Until r = iIndex
  If S Then
     S = S + Len(sField)
     e = InStr(S, sHeader, vbCrLf, vbBinaryCompare)
     If e Then
        ExtractHeader = Mid(sHeader, S, e - S)
     End If
  End If
End Function

' ####################################################################################################################################
' ----------------------------------------------- PRIVATE SCOPE FUNCTIONS ------------------------------------------------------------
' ####################################################################################################################################

Private Sub ShowStatus(ByVal BytesReceived As Long, ByVal BytesTotal As Long)
   If Not cStatus Is Nothing And BytesTotal > 0 Then
      Dim p As String
      With cStatus
        p = Round((BytesReceived / BytesTotal) * 100, 0) & "%"
        .Cls
        .ForeColor = colPrg
        cStatus.Line (0, 0)-((BytesReceived / BytesTotal) * .ScaleWidth, .ScaleHeight), , BF
        .CurrentX = .ScaleWidth \ 2 - .TextWidth(p) \ 2
        .CurrentY = .ScaleHeight \ 2 - .TextHeight(p) \ 2
        .ForeColor = colText
        cStatus.Print p
      End With
   End If
End Sub

Private Function Base64Encode(ByVal sStr As String) As String
  ' ### creates a base64 encoded string from sStr according to RFC 2045
  Dim i      As Long
  Dim j      As Long
  Dim sOut   As String
  Dim pOut   As String
  Dim nGroup As Long
  Dim sGroup As String
  Const Base64 As String = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
  For i = 1 To Len(sStr) Step 3
    nGroup = Asc(Mid(sStr, i, 1)) * &H10000
    If (i + 1) <= Len(sStr) Then nGroup = nGroup + Asc(Mid(sStr, i + 1, 1)) * &H100&
    If (i + 2) <= Len(sStr) Then nGroup = nGroup + Asc(Mid(sStr, i + 2, 1))
    nGroup = Oct(nGroup)
    sGroup = Right("00000000" & Str(nGroup), 8)
    pOut = vbNullString
    For j = 1 To 8 Step 2
        pOut = pOut & Mid(Base64, CLng("&o" & Mid(sGroup, j, 2)) + 1, 1)
    Next
    sOut = sOut + pOut
    If (i + 2) Mod 57 = 0 Then sOut = sOut + vbCrLf
  Next
  Select Case Len(sStr) Mod 3
    Case 1: sOut = Left(sOut, Len(sOut) - 2) + "=="    '8 bit final
    Case 2: sOut = Left(sOut, Len(sOut) - 1) + "="     '16 bit final
  End Select
  Base64Encode = sOut
End Function

Private Function CrackURL(ByVal sURL As String) As URL_COMPONENTSA
  ' ### splits sURL into it's component parts
  Dim Components As URL_COMPONENTSA
  With Components
     .lpszScheme = Space(INTERNET_MAX_SCHEME_LENGTH)
     .dwSchemeLength = INTERNET_MAX_SCHEME_LENGTH
     .lpszHostName = Space(INTERNET_MAX_HOST_NAME_LENGTH)
     .dwHostNameLength = INTERNET_MAX_HOST_NAME_LENGTH
     .lpszUsername = Space(INTERNET_MAX_USER_NAME_LENGTH)
     .dwUserNameLength = INTERNET_MAX_USER_NAME_LENGTH
     .lpszPassword = Space(INTERNET_MAX_USER_NAME_LENGTH)
     .dwPasswordLength = INTERNET_MAX_USER_NAME_LENGTH
     .lpszUrlPath = Space(INTERNET_MAX_PATH_LENGTH)
     .dwUrlPathLength = INTERNET_MAX_PATH_LENGTH
     .lpszExtraInfo = Space(128)
     .dwExtraInfoLength = 128
     .dwStructSize = Len(Components) + 2
  End With
  With Components
    If InternetCrackUrl(sURL, Len(sURL), ICU_DECODE, Components) Then
       .lpszScheme = Left(.lpszScheme, .dwSchemeLength)
       .lpszHostName = Left(.lpszHostName, .dwHostNameLength)
       .lpszUsername = Left(.lpszUsername, .dwUserNameLength)
       .lpszPassword = Left(.lpszPassword, .dwPasswordLength)
       .lpszUrlPath = Left(.lpszUrlPath, .dwUrlPathLength)
       .lpszExtraInfo = Left(.lpszExtraInfo, .dwExtraInfoLength)
    Else
       .lpszScheme = vbNullString
       .lpszHostName = vbNullString
       .lpszUsername = vbNullString
       .lpszPassword = vbNullString
       .lpszUrlPath = vbNullString
       .lpszExtraInfo = vbNullString
    End If
  End With
  CrackURL = Components
End Function

Private Sub Class_Terminate()
  ' ### destroy some objects
  If hRequest Then Call InternetCloseHandle(hRequest)
  If hConnect Then Call InternetCloseHandle(hConnect)
  If hSession Then Call InternetCloseHandle(hSession)
  Set cStatus = Nothing
End Sub
